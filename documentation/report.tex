%%
% Report of my internship.
% It has to give an introduction to the context and explain my work.
%%
\documentclass[12px]{article}

\usepackage[noend]{algpseudocode}
\usepackage[english]{babel}
\usepackage[a4paper]{geometry}
\usepackage[hidelinks]{hyperref}

\usepackage{algorithm}
\usepackage{apacite}
\usepackage{stmaryrd}
\usepackage{tikz}


\begin{document}
  \section{Introduction}
    % Some bullshit is expected here I guess ?
    % Goal of the internship (maybe quickly as not everything is supposed to be introduced)
    % Technical informations about the internship, team, ...

  \section{Context and state of the art}
    % Give any information about what isn't my work
    \subsection{Union-Find algorithms}
      \subsubsection{Disjoint set structure}
        % Definition of a disjoint set structure
        The disjoint set structure is a very classical structure that represents a partition of a finite set $X = \biguplus\limits_{i \in I} S_i$. It is meant to allow three fast queries:
        \begin{itemize}
          \item $\Call{makeset}{a}$: add the element $a$ to the structure, initially in a singleton.
          \item $\Call{Union}{a, b}$: alter the structure to merge the set $a$ belongs to and the set $b$ belongs to. After such an operation, $\exists! i \in I~/~a \in S_i \land b \in S_i$.
          \item $\Call{find}{a}$: give a unique representative of the set $a$ belongs to. It means that $\forall a, b \in X,~\Call{find}{a} = \Call{find}{b} \Leftrightarrow \exists! i \in I~/~a \in S_i \land b \in S_i$.
        \end{itemize}
        In practice, it is usually represented by a forest of the elements of $X$, $\textsc{makeset}$ builds a tree containing only its root, $\textsc{union}$ merges two trees and $\textsc{find}$ returns the root of a tree given one of its nodes.
        In a program, such a forest is represented by an array of size $|X|$, assuming that $X = \llbracket 0, |X|-1 \rrbracket$, the element of index $a$ will be $b$ if b is the parent of $a$ in a tree, or $a$ if $a$ is a root.

        \begin{figure}[h]
          \caption{A disjoint set structure representing $\{\{0, 1, 2\}, \{3\}, \{4, 5\}\}$}
          \centering
          \vspace{0.2cm}
          \begin{tikzpicture}[shorten >=1pt]
            \tikzstyle{vertex} = [circle, draw=black]
            \tikzstyle{legend} = [color=gray, font=\tiny]

            \node[vertex] (0) at (1, 1) {$0$};
            \node[vertex] (1) at (0.5, 0) {$1$};
            \node[vertex] (2) at (1.5, 0) {$2$};
            \node[vertex] (3) at (3, 0) {$3$};
            \node[vertex] (4) at (3, 1) {$4$};
            \node[vertex] (5) at (4.5, 0.5) {$5$};

            \draw [->] (0.90) arc (1:264:3mm) {};
            \draw [->] (4.90) arc (1:264:3mm) {};
            \draw [->] (5.90) arc (1:264:3mm) {};

            \draw [->] (1) -- (0);
            \draw [->] (2) -- (0);
            \draw [->] (3) -- (4);
          \end{tikzpicture}
          \hspace{1cm}
          \raisebox{0.5cm}{
            \begin{tikzpicture}[shorten >=1pt]
              \tikzstyle{value} = [draw=black, fill=blue!15, minimum width=0.5cm, minimum height=0.5cm]
              \tikzstyle{index} = [color=darkgray, font=\small]

              \foreach \i / \x in {0/0, 1/0, 2/0, 3/4, 4/4, 5/5}
                \node[index] at (\i / 2, 0.5) {\i};
              \foreach \i / \x in {0/0, 1/0, 2/0, 3/4, 4/4, 5/5}
                \node[value] at (\i / 2, 0) {\x};

            \end{tikzpicture}
          }
        \end{figure}

      \subsubsection{Classical union-find algorithm}
        % Classical th. implementation of union-find, explaination why (th. complexity), applications ?
        A very typical application of this structure is to find a spaning forest of an undirected graph. A general algorithm used to answer this problem is called \emph{union-find} (alg. \ref{alg:union-find}).

        Typically, \textsc{find} runs over the tree until it reaches the root, keeps track of every nodes on the path and finally set their parent to be the root. In this case \textsc{union} doesn't need to compress the trees and will just make one of the roots be parent of the other, the new root can be chosen arbitrary or given a criteria (index, rank, ...).

      \begin{algorithm}[bh]
        \caption{General structure of union-find}
        \label{alg:union-find}
        \begin{algorithmic}[1]
          \State $F \leftarrow \emptyset$
          \ForAll {$x \in V$}
            \State \Call{makeset}{x}
          \EndFor
          \ForAll {$(x, y) \in E$}
            \If {$\Call{find}{x} \neq \Call{find}{y}$}
              \State $\Call{union}{x, y}$
            \EndIf
          \EndFor
        \end{algorithmic}
      \end{algorithm}

      This algorithm can actualy be implemented with many variations (\citeA{ufexp10}), where a typical goal is to make sure that trees never get too high, thus compressing the path leading to the root while processing \textsc{find} operation.


      \subsubsection{REM algorithm}
        % Definition and analysis of REM, explaination on why it is awesome

    \subsection{Distributed algorithms}
      % Introduction to distributed algorithmic, existing implementation

    \subsection{Shared algorithms}
      % Introduction to shared algorithmic, existing implementation


  \section{Writing REM as a distributed memory algorithm}
    % Description of the algorithm, experimental results


  \section{Mixing up distributed and shared algorithms}
    % Description of parallelized parts, experimental results


  \section{Conclusion}


  \section{Appendices}
    % Proofs, maybe extra datas
    \citeA{ufdist09}
    \citeA{ufexp10}


  \bibliographystyle{apacite}
  \bibliography{references}
\end{document}
